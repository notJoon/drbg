package nist

import (
	"math"

	b "github.com/notJoon/drbg/bitstream"
)

// go run main.go -file rand_data/pcg32.bin -linear -m 600

// LinearComplexity implements the linear complexity test from NIST SP-800-22.
// The purpose of this test is to determine the length of the linear feedback shift register (LFSR)
// that generates the given sequence. The linear complexity of a sequence is the length of the shortest
// LFSR that can generate the sequence.
//
// The test partitions the input sequence into N independent blocks of length M, where n = M*N and n is the length
// of the input sequence. It then determines the linear complexity of each block using the Berlekamp-Massey algorithm.
//
// The Berlekamp-Massey algorithm is an iterative algorithm that finds the shortest LFSR that generates a given
// sequence. It maintains two arrays: C (the connection polynomial) and B (the feedback polynomial). At each iteration,
// it computes the discrepancy d between the next bit of the sequence and the bit generated by the current LFSR.
// If d is 1, it updates the connection polynomial C and the feedback polynomial B.
//
// The test computes the theoretical mean and a normalized value T for each block's linear complexity. It then counts
// the occurrences of T values in predefined ranges and computes a chi-square statistic. Finally, it computes the
// p-value using the incomplete gamma function.
//
// The test returns the p-value, a boolean indicating whether the p-value is greater than or equal to 0.01 (the significance
// level), and an error (if any).
//
// Recommended input
// 500 ≤ M ≤ 5000
func LinearComplexity(M uint64, bs *b.BitStream) (float64, bool, error) {
	n := bs.Len() // n ≥ 1e6
	N := uint64(n) / M
	blocks := make([][]uint8, 0, N)

	// partition the n-nit sequence into N independent blocks of length M. (where, n = M*N)
	for i := uint64(0); i < N; i++ {
		if i*M+M > uint64(n) {
			break
		}
		block := make([]uint8, M)
		for j := uint64(0); j < M; j++ {
			bit, err := bs.Bit(int(i*M + j))
			if err != nil {
				return 0, false, err
			}
			block[j] = bit
		}
		blocks = append(blocks, block)
	}

	// determine the linear complexity of each block
	L := make([]uint64, N)
	for i := range L {
		L[i] = berlekampMassey(blocks[i])
	}

	mu := float64(M)/2.0 + (9.0+math.Pow(-1.0, float64(M+1)))/36.0 - (float64(M)/3.0+0.2222222222)/math.Pow(2.0, float64(M))

	// calculate a value of T[i] for each substring.
	T := make([]float64, N)
	v := make([]float64, 7)

	for i := range T {
		T[i] = math.Pow(-1.0, float64(M))*(float64(L[i])-mu) + 2.0/9.0

		// record the T_i values in v_0 to v_6
		if T[i] <= -2.5 {
			v[0]++
		} else if T[i] <= -1.5 {
			v[1]++
		} else if T[i] <= -0.5 {
			v[2]++
		} else if T[i] <= 0.5 {
			v[3]++
		} else if T[i] <= 1.5 {
			v[4]++
		} else if T[i] <= 2.5 {
			v[5]++
		} else {
			v[6]++
		}
	}

	PI := []float64{0.010417, 0.03125, 0.125, 0.5, 0.25, 0.0625, 0.020833}
	K := 6 // degrees of freedom (K = 6 as defined in SP 800-22)
	chi_2 := 0.0

	var N_pi float64
	for i := 0; i <= K; i++ {
		N_pi = float64(N) * PI[i]
		chi_2 += math.Pow(v[i]-N_pi, 2) / N_pi
	}

	p_val := igamc(float64(K)/2.0, chi_2/2.0)

	return p_val, p_val >= 0.01, nil
}

// berlekampMassey implements the Berlekamp-Massey algorithm for determining the linear complexity of a binary sequence.
// The algorithm finds the shortest LFSR that generates the given sequence.
//
// It maintains two arrays:
// - C: the connection polynomial, representing the current LFSR
// - B: the feedback polynomial, used to update C when the discrepancy is 1
//
// At each iteration, it computes the discrepancy d between the next bit of the sequence and the bit generated by the
// current LFSR. If d is 1, it updates C and B using a temporary array T.
//
// The algorithm returns the length of the shortest LFSR (the linear complexity of the sequence).
func berlekampMassey(s []uint8) uint64 {
	var (
		d = uint64(0)
		n = len(s)
		C = make([]uint64, n)
		B = make([]uint64, n)
		T = make([]uint64, n)
		P = make([]uint64, n)
	)

	L, m := 0, -1
	C[0] = 1
	B[0] = 1.0

	// determine linear complexity
	N := 0
	M := n // block size
	for {
		if N >= M {
			break
		}

		d = uint64(s[N])
		for i := 1; i <= L; i++ {
			d += uint64(C[i]) * uint64(s[N-i])
		}
		d = d % 2
		if d == 1 {
			for i := 0; i < M; i++ {
				T[i] = C[i]
				P[i] = 0
			}
			for j := 0; j < M; j++ {
				if B[j] == 1 {
					P[j+N-m] = 1
				}
			}

			for k := 0; k < M; k++ {
				C[k] = (C[k] + P[k]) % 2
			}

			if L <= N/2 {
				L = N + 1 - L
				m = N
				for i := 0; i < M; i++ {
					B[i] = T[i]
				}
			}
		}
		N++
	}

	return uint64(L)
}
